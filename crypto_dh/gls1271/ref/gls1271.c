/*

Example ECC point multiply program for 64-bit environments. 
Stack-only memory allocation

Use with this mirdef.h header (for a PC using MS C)

#define MR_LITTLE_ENDIAN
#define MIRACL 64
#define mr_utype long
#define MR_IBITS 32
#define MR_LBITS 64
#define mr_unsign32 unsigned int
#define MR_STATIC 2
#define MR_ALWAYS_BINARY
#define MR_STRIPPED_DOWN
#define MR_GENERIC_MT
#define MAXBASE ((mr_small)1<<(MIRACL-1))
#define MR_BITSINCHAR 8
#define MR_COMBA 2
#define MR_GENERALIZED_MERSENNE
#define MR_SPECIAL
#define MR_NO_LAZY_REDUCTION

Build the library from these modules (Example using MS C compiler)

./mex 2 amd64 mrcomba

gcc -c -O2 mrcore.c
gcc -c -O2 mrarth0.c
gcc -c -O2 mrarth1.c
gcc -c -O2 mrio1.c
gcc -c -O2 mrbits.c
gcc -c -O2 mrcurve.c
gcc -c -O2 mrsroot.c
gcc -c -O2 mrjack.c
gcc -c -O2 mrlucas.c
gcc -c -O2 mrsmall.c
gcc -c -O2 mrarth2.c
gcc -c -O2 mrmonty.c
gcc -c -O2 mrcomba.c
gcc -c -O2 mrxgcd.c
gcc -c -O2 mrzzn2.c
gcc -c -O2 mrecn2.c
as mrmuldv.s64 -o mrmuldv.o

ar rc miracl.a mrcore.o mrarth0.o mrarth1.o mrarth2.o mrsmall.o
ar r miracl.a mrio1.o mrjack.o mrxgcd.o mrbits.o 
ar r miracl.a mrmonty.o mrcurve.o mrsroot.o mrzzn2.o
ar r miracl.a mrlucas.o mrmuldv.o mrcomba.o mrecn2.o
rm mr*.o
gcc -O2 t128_64.c miracl.a -o t128_64

*/

#include <stdio.h>
#include <string.h>
#include "miracl.h"
#include "crypto_dh.h"
#include "randombytes.h"

#define CURVE_BITS 127

/* Curve details */

static const mr_small rom[]=
{
0xFFFFFFFFFFFFFFFF,0x7FFFFFFFFFFFFFFF,
0x2C,0x0,
0x999999999999999A,0x1999999999999999,  	
0xCCCCCCCCCCCCCCCD,0x4CCCCCCCCCCCCCCC,
0x1AFAC10F88821962,0x12B04E814703D49C, 
0x6F755142FE73FB62,0x426B94A2AD451F29,
0x2F55509EF630FF5A,0x422DD1650E025949,
0xD4CB6C64E26DB09F,0x6ED444D53BF7F6E7,
0x2E89D9B064BE2B44,0x4813CC47356300D3,
0x6F93B4024817C634,0x430F590203CB7DF8 
};

#ifdef MR_COUNT_OPS
int fpm2,fpi2,fpc,fpa,fpx;
#endif

#define WORDS 2  /* Number of words per big variable 2*64 = 128 */

/* Note that in a real application a source of real random numbers would be required, to
   replace those generated by MIRACL's internal pseudo-random generator "bigbits"  
   Alternatively from a truly random and unguessable seed, use MIRACL's strong random 
   number generator */

/* Elliptic Curve Diffie-Hellman, using point compression to minimize bandwidth, 
   and precomputation to speed up off-line calculation */


int crypto_dh_keypair(unsigned char* pk,unsigned char *sk)
{
    int i,promptr;
    ecn2 P,Q;
    big A,B,p,a_0,a_1;
    zzn2 x,y,psi_x,psi_y;
    miracl instance;      /* create miracl workspace on the stack */

/* Specify base 16 here so that HEX can be read in directly without a base-change */

    miracl *mip=mirsys(&instance,WORDS*16,16); /* size of bigs is fixed */
    char mem_big[MR_BIG_RESERVE(50)];          /* we need 10 bigs... */
 	memset(mem_big, 0, MR_BIG_RESERVE(25));    /* clear the memory */

    A=mirvar_mem(mip, mem_big, 0);       /* Initialise big numbers */
    B=mirvar_mem(mip, mem_big, 1);
    x.a=mirvar_mem(mip, mem_big, 2);
    x.b=mirvar_mem(mip, mem_big, 3);
    y.a=mirvar_mem(mip, mem_big, 4);
    y.b=mirvar_mem(mip, mem_big, 5);
    a_0=mirvar_mem(mip, mem_big, 6);
    a_1=mirvar_mem(mip, mem_big, 7);
    p=mirvar_mem(mip, mem_big, 8);
    P.x.a=mirvar_mem(mip, mem_big, 9);
    P.x.b=mirvar_mem(mip, mem_big, 10);
    P.y.a=mirvar_mem(mip, mem_big, 11);
    P.y.b=mirvar_mem(mip, mem_big, 12);
    P.z.a=mirvar_mem(mip, mem_big, 13);
    P.z.b=mirvar_mem(mip, mem_big, 14);
    Q.x.a=mirvar_mem(mip, mem_big, 15);
    Q.x.b=mirvar_mem(mip, mem_big, 16);
    Q.y.a=mirvar_mem(mip, mem_big, 17);
    Q.y.b=mirvar_mem(mip, mem_big, 18);
    Q.z.a=mirvar_mem(mip, mem_big, 19);
    Q.z.b=mirvar_mem(mip, mem_big, 20);
	psi_x.a=mirvar_mem(mip, mem_big, 21);
	psi_x.b=mirvar_mem(mip, mem_big, 22);
	psi_y.a=mirvar_mem(mip, mem_big, 23);
	psi_y.b=mirvar_mem(mip, mem_big, 24);

    promptr=0;
    init_big_from_rom(p,WORDS,rom,20,&promptr);  /* Read in prime modulus p from ROM   */
    init_big_from_rom(B,WORDS,rom,20,&promptr);  /* Read in curve parameter B from ROM */
	init_big_from_rom(psi_x.a,WORDS,rom,20,&promptr);
	init_big_from_rom(psi_x.b,WORDS,rom,20,&promptr);
	init_big_from_rom(psi_y.a,WORDS,rom,20,&promptr);
	init_big_from_rom(psi_y.b,WORDS,rom,20,&promptr);
	init_big_from_rom(x.a,WORDS,rom,20,&promptr);
	init_big_from_rom(x.b,WORDS,rom,20,&promptr);
	init_big_from_rom(y.a,WORDS,rom,20,&promptr);
	init_big_from_rom(y.b,WORDS,rom,20,&promptr);
                                                 
    convert(mip,-3,A);                           /* set A=1 */

    ecurve_init(mip,A,B,p,MR_PROJECTIVE);
    mip->TWIST=TRUE;

	if (!ecn2_set(mip,&x,&y,&P))
	{
		memset(mem_big, 0, MR_BIG_RESERVE(25));
		mirexit(mip);
		return -1;
	}

/* Alices key gen calculation */

    randombytes(sk,32);
	sk[15]&=0x7f; sk[31]&=0x7f;

	bytes_to_big(mip,16,sk,a_0);
	bytes_to_big(mip,16,&sk[16],a_1);
	ecn2_copy(&P,&Q);
	ecn2_psi(mip, &psi_x,&psi_y,&Q);  /* apply endomorphism */
    ecn2_mul2(mip,a_0,&P,a_1,&Q,&P);

    big_to_bytes(mip,16,P.x.a,pk,TRUE);
    big_to_bytes(mip,16,P.x.b,&pk[16],TRUE);
    big_to_bytes(mip,16,P.y.a,&pk[32],TRUE);
    big_to_bytes(mip,16,P.y.b,&pk[48],TRUE);

    memset(mem_big, 0, MR_BIG_RESERVE(25));
	mirexit(mip);

	return 0;
}

int crypto_dh(unsigned char *s,const unsigned char* pk,const unsigned char *sk)
{
    int i,promptr;
    ecn2 P,Q;
    big A,B,p,a_0,a_1;
    zzn2 x,y,psi_x,psi_y;
    miracl instance;      /* create miracl workspace on the stack */

/* Specify base 16 here so that HEX can be read in directly without a base-change */

    miracl *mip=mirsys(&instance,WORDS*16,16); /* size of bigs is fixed */
    char mem_big[MR_BIG_RESERVE(50)];          /* we need 10 bigs... */
 	memset(mem_big, 0, MR_BIG_RESERVE(25));    /* clear the memory */

    A=mirvar_mem(mip, mem_big, 0);       /* Initialise big numbers */
    B=mirvar_mem(mip, mem_big, 1);
    x.a=mirvar_mem(mip, mem_big, 2);
    x.b=mirvar_mem(mip, mem_big, 3);
    y.a=mirvar_mem(mip, mem_big, 4);
    y.b=mirvar_mem(mip, mem_big, 5);
    a_0=mirvar_mem(mip, mem_big, 6);
    a_1=mirvar_mem(mip, mem_big, 7);
    p=mirvar_mem(mip, mem_big, 8);
    P.x.a=mirvar_mem(mip, mem_big, 9);
    P.x.b=mirvar_mem(mip, mem_big, 10);
    P.y.a=mirvar_mem(mip, mem_big, 11);
    P.y.b=mirvar_mem(mip, mem_big, 12);
    P.z.a=mirvar_mem(mip, mem_big, 13);
    P.z.b=mirvar_mem(mip, mem_big, 14);
    Q.x.a=mirvar_mem(mip, mem_big, 15);
    Q.x.b=mirvar_mem(mip, mem_big, 16);
    Q.y.a=mirvar_mem(mip, mem_big, 17);
    Q.y.b=mirvar_mem(mip, mem_big, 18);
    Q.z.a=mirvar_mem(mip, mem_big, 19);
    Q.z.b=mirvar_mem(mip, mem_big, 20);
	psi_x.a=mirvar_mem(mip, mem_big, 21);
	psi_x.b=mirvar_mem(mip, mem_big, 22);
	psi_y.a=mirvar_mem(mip, mem_big, 23);
	psi_y.b=mirvar_mem(mip, mem_big, 24);
 
    promptr=0;
    init_big_from_rom(p,WORDS,rom,20,&promptr);  /* Read in prime modulus p from ROM   */
    init_big_from_rom(B,WORDS,rom,20,&promptr);  /* Read in curve parameter B from ROM */
	init_big_from_rom(psi_x.a,WORDS,rom,20,&promptr);
	init_big_from_rom(psi_x.b,WORDS,rom,20,&promptr);
	init_big_from_rom(psi_y.a,WORDS,rom,20,&promptr);
	init_big_from_rom(psi_y.b,WORDS,rom,20,&promptr);
	init_big_from_rom(x.a,WORDS,rom,20,&promptr);
	init_big_from_rom(x.b,WORDS,rom,20,&promptr);
	init_big_from_rom(y.a,WORDS,rom,20,&promptr);
	init_big_from_rom(y.b,WORDS,rom,20,&promptr);
                                                 
    convert(mip,-3,A);                           /* set A=1 */

/* offline calculations */

    ecurve_init(mip,A,B,p,MR_PROJECTIVE);
    mip->TWIST=TRUE;

	if (!ecn2_set(mip,&x,&y,&P)) 
	{
		memset(mem_big, 0, MR_BIG_RESERVE(25));
		mirexit(mip);
		return -1;
	}

/* Alice calculates secret key */

	bytes_to_big(mip,16,pk,x.a);
	bytes_to_big(mip,16,&pk[16],x.b);
	bytes_to_big(mip,16,&pk[32],y.a);
	bytes_to_big(mip,16,&pk[48],y.b);
	bytes_to_big(mip,16,sk,a_0);
	bytes_to_big(mip,16,&sk[16],a_1);
	
	if (!ecn2_set(mip,&x,&y,&P))
	{
		memset(mem_big, 0, MR_BIG_RESERVE(25));
		mirexit(mip);
		return -1;
	}

	ecn2_copy(&P,&Q);
	ecn2_psi(mip, &psi_x,&psi_y,&Q);  /* apply endomorphism */
    ecn2_mul2(mip,a_0,&P,a_1,&Q,&P);

    big_to_bytes(mip,16,P.x.a,s,TRUE);
    big_to_bytes(mip,16,P.x.b,&s[16],TRUE);

    memset(mem_big, 0, MR_BIG_RESERVE(25));
	mirexit(mip);

	return 0;
}

int copyrightclaims()
{
	return 30;
}

int timingattacks()
{
	return 100;
}

int patentclaims()
{
	return 0;
}

